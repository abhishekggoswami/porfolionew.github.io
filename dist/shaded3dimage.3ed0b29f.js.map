{"version":3,"sources":["assets/js/shaded3dimage.js"],"names":[],"mappings":";;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA","file":"shaded3dimage.3ed0b29f.js","sourceRoot":"..\\src","sourcesContent":["\r\n\r\n/*import * as THREE from \"three\";  \r\nimport images from \"./images\";  \r\nconst loader = new THREE.TextureLoader();  \r\nimport vertex from \"../shaders/shaders/vertex.glsl\";  \r\nimport fragment from \"../shaders/shaders/fragment.glsl\";  \r\n  \r\nconst texture1 = loader.load(images.me1);  \r\nconst texture2 = loader.load(images.me2);  \r\nconst texture3 = loader.load(images.me3);  \r\n  \r\nfunction lerp(start, end, t) {  \r\n  return start * (1 - t) + end * t;  \r\n}  \r\n  \r\nclass Shaded {  \r\n  constructor() {  \r\n    this.container = document.querySelector(\".landing\");  \r\n    this.inner = document.querySelector(\".intro\");  \r\n    this.links = [...document.querySelectorAll(\"#shadedimg\")];  \r\n    this.targetX = 0;  \r\n    this.targetY = 0;  \r\n    this.scene = new THREE.Scene();  \r\n    this.perspective = 1000;  \r\n    this.sizes = new THREE.Vector2(0, 0);  \r\n    this.offset = new THREE.Vector2(0, 0);  \r\n    this.uniforms = {  \r\n      uTexture: { value: texture1 },  \r\n      uAlpha: { value: 0.0 },  \r\n      uOffset: { value: new THREE.Vector2(0.0, 0.0) },  \r\n      transparent: true,  \r\n    };  \r\n  \r\n    this.links.map((link, i) => {  \r\n      link.addEventListener(\"mouseenter\", () => {  \r\n        switch (i) {  \r\n          case 0:  \r\n            this.uniforms.uTexture.value = texture1;  \r\n            break;  \r\n          case 1:  \r\n            this.uniforms.uTexture.value = texture2;  \r\n            break;  \r\n          case 2:  \r\n            this.uniforms.uTexture.value = texture3;  \r\n            break;  \r\n        }  \r\n      });  \r\n      link.addEventListener(\"mouseleave\", () => {  \r\n        this.uniforms.uAlpha.value = lerp(this.uniforms.uAlpha.value, 0.0, 0.1);  \r\n      });  \r\n    });  \r\n  \r\n    this.checkHovered();  \r\n    this.setupCamera();  \r\n    this.followMouseMove();  \r\n    this.createMesh();  \r\n    this.render();  \r\n  }  \r\n  \r\n  get viewport() {  \r\n    let width = window.innerWidth;  \r\n    let height = window.innerHeight;  \r\n    let aspectRatio = width / height;  \r\n    let pixelRatio = window.devicePixelRatio;  \r\n    return { width, height, aspectRatio, pixelRatio };  \r\n  }  \r\n  \r\n  checkHovered() {  \r\n    this.inner.addEventListener(\"mouseenter\", () => {  \r\n      this.hovered = true;  \r\n    });  \r\n    this.inner.addEventListener(\"mouseleave\", () => {  \r\n      this.hovered = false;  \r\n      this.uniforms.uTexture = { value: texture1 };  \r\n    });  \r\n  }  \r\n  \r\n  setupCamera() {  \r\n    window.addEventListener(\"resize\", this.onResize.bind(this));  \r\n    let fov = (180 * (2 * Math.atan(this.viewport.height / 2 / this.perspective))) / Math.PI;  \r\n    this.camera = new THREE.PerspectiveCamera(fov, this.viewport.aspectRatio, 0.1, 1000);  \r\n    this.camera.position.set(0, 0, this.perspective);  \r\n    // renderer  \r\n    this.renderer = new THREE.WebGLRenderer({  \r\n      antialias: true,  \r\n      alpha: true,  \r\n    });  \r\n    this.renderer.setSize(this.viewport.width, this.viewport.height);  \r\n    this.renderer.setPixelRatio(this.viewport.pixelRatio);  \r\n    this.container.appendChild(this.renderer.domElement);  \r\n  }  \r\n  \r\n  createMesh() {  \r\n    this.geometry = new THREE.PlaneGeometry(0.7, 0.7, 20, 20);  \r\n    this.material = new THREE.ShaderMaterial({  \r\n      uniforms: this.uniforms,  \r\n      vertexShader: vertex,  \r\n      fragmentShader: fragment,  \r\n      transparent: true,  \r\n    });  \r\n    this.mesh = new THREE.Mesh(this.geometry, this.material);  \r\n    this.sizes.set(370, 470, 1);  \r\n    this.mesh.scale.set(this.sizes.x, this.sizes.y, 1);  \r\n    this.mesh.position.set(this.offset.x, this.offset.y, 0);  \r\n    this.scene.add(this.mesh);  \r\n  }  \r\n  \r\n  followMouseMove() {  \r\n    window.addEventListener(\"mousemove\", (e) => {  \r\n      this.targetX = e.clientX;  \r\n      this.targetY = e.clientY;  \r\n    });  \r\n  }  \r\n  \r\n  onResize() {  \r\n    this.camera.aspect = this.viewport.aspectRatio;  \r\n    this.camera.fov = (180 * (2 * Math.atan(this.viewport.height / 2 / this.perspective))) / Math.PI;  \r\n    this.renderer.setSize(this.viewport.width, this.viewport.height);  \r\n    this.camera.updateProjectionMatrix();  \r\n  }  \r\n  \r\n  render() {  \r\n    this.offset.x = lerp(this.offset.x, this.targetX, 0.1);  \r\n    this.offset.y = lerp(this.offset.y, this.targetY, 0.1);  \r\n    this.uniforms.uOffset.value.set((this.targetX - window.innerWidth / 2) * 0.0003, -(this.targetY - window.innerHeight / 2) * 0.0003);  \r\n    this.mesh.position.set(this.offset.x - window.innerWidth / 2, -this.offset.y + window.innerHeight / 2);  \r\n    this.hovered  \r\n     ? (this.uniforms.uAlpha.value = lerp(this.uniforms.uAlpha.value, 1.0, 0.1))  \r\n      : (this.uniforms.uAlpha.value = lerp(this.uniforms.uAlpha.value, 0.0, 0.1));  \r\n    this.renderer.render(this.scene, this.camera);  \r\n    window.requestAnimationFrame(this.render.bind(this)); // Add this line to create an animation loop  \r\n  }  \r\n}  \r\n  \r\nnew Shaded();  \r\n\r\n\r\n\r\n/*import * as THREE from \"three\";\r\nimport images from \"./images\";\r\nconst loader = new THREE.TextureLoader()\r\n\r\n\r\nimport vertex from \"../shaders/shaders/vertex.glsl\";\r\nimport fragment from \"../shaders/shaders/fragment.glsl\";\r\n\r\nconst texture1 = loader.load(images.me1);\r\nconst texture2 = loader.load(images.me2);\r\nconst texture3 = loader.load(images.me3);\r\nfunction lerp(start, end, t){\r\n    return start * (1-t) + end * t;\r\n}\r\n\r\nclass Shaded{\r\n    constructor() {\r\n        this.container = document.querySelector(\".landing\");\r\n        this.inner = document.querySelector(\".intro\");\r\n        this.links = [...document.querySelectorAll(\"#shadedimg\")];\r\n        this.targetX = 0;\r\n        this.targetY = 0;\r\n\r\n        this.scene = new THREE.Scene();\r\n        this.perspective = 1000;\r\n        this.sizes = new THREE.Vector2(0, 0);\r\n        this.offset = new THREE.Vector2(0, 0);\r\n        this.uniforms = {\r\n            uTexture:{value: texture1},\r\n            uAlpha: {value: 0.0},\r\n            uOffset: {\r\n                value: new THREE.Vector2(0.0, 0.0)\r\n            },\r\n            transparent: true,\r\n        };\r\n        this.links.map((link,i)=>{\r\n            link.addEventListener('mouseenter', ()=>{\r\n                switch(i){\r\n                    case 0:\r\n                        this.uniforms.uTexture.value = texture1;\r\n                        break;\r\n                    case 1:\r\n                        this.uniforms.uTexture.value = texture2;\r\n                        break;\r\n                    case 2:\r\n                        this.uniforms.uTexture.value = texture3;\r\n                        break;\r\n                }\r\n            });\r\n            link.addEventListener('mouseleave', ()=>{\r\n                this.uniforms.uAlpha.value = lerp(this.uniforms.uAlpha.value, 0.0, 0.1);\r\n            });\r\n        });\r\n        this.checkHovered();\r\n        this.setupCamera();\r\n        this.followMouseMove();\r\n        this.createMesh();\r\n        this.render();\r\n    }\r\n\r\n    get viewport(){\r\n        let width = window.innerWidth;\r\n        let height = window.innerHeight;\r\n        let aspectRatio = width / height;\r\n        let pixelRatio = window.devicePixelRatio;\r\n\r\n        return{\r\n\r\n            width,\r\n            height,\r\n            aspectRatio,\r\n            pixelRatio,\r\n\r\n        };\r\n    }\r\n    checkHovered(){\r\n        this.inner.addEventListener('mouseenter' ,()=>{\r\n            this.hovered = true;\r\n\r\n        });\r\n        this.inner.addEventListener('mouseleave' ,()=>{\r\n            this.hovered = false;\r\n            this.uniforms.uTexture = {value: texture1 };\r\n\r\n        });\r\n\r\n    }\r\n\r\n\r\n    setupCamera(){\r\n        window = addEventListener(\"resize\", this.onResize.bind(this));\r\n        let fov =\r\n        (180 * (2 * Math.atan(this.viewport.height / 2 / this.perspective))) / Math.PI;\r\n\r\n        this.camera = new THREE.PerspectiveCamera(\r\n            fov,\r\n            this.viewport.aspectRatio,\r\n            0.1,\r\n            1000\r\n        );\r\n        this.camera.position.set(0,0, this.perspective);\r\n\r\n        //renderer\r\n        this.renderer = new THREE.WebGLRenderer({\r\n            antialias: true,\r\n            alpha: true,\r\n\r\n        });\r\n        this.renderer.setSize(this.viewport.width, this.viewport.height);\r\n\r\n        this.renderer.setPixelRatio(this.viewport.pixelRatio);\r\n\r\n        this.container.appendChild(this.renderer.domElement);\r\n\r\n\r\n    }\r\n    createMesh(){\r\n        this.geometry = new THREE.PlaneGeometry(1, 1, 20, 20);\r\n        this.material = new THREE.ShaderMaterial( {\r\n\r\n            uniforms: this.uniforms,\r\n            vertexShader : vertex,\r\n            fragmentShader : fragment,\r\n            transparent: true,\r\n\r\n        });\r\n        this.mesh = new THREE.Mesh(this.geometry, this.material);\r\n        this.sizes.set(370, 470, 1);\r\n        this.mesh.scale.set(this.sizes.x, this.sizes.y, 1);\r\n        this.mesh.position.set(this.offset.x, this.offset.y, 0);\r\n        this.scene.add(this.mesh);\r\n    }\r\n    followMouseMove() {\r\n        window.addEventListener('mousemove', (e)=>{\r\n            this.targetX= e.clientX;\r\n            this.targetY= e.clientY;\r\n\r\n        })\r\n    }\r\n    onResize(){\r\n        this.camera.aspect = this.viewport.aspectRatio;\r\n        this.camera.fov =\r\n        (180 * (2 * Math.atan(this.viewport.height / 2 / this.perspective))) / Math.PI;\r\n\r\n        this.renderer.setSize(this.viewport.width, this.viewport.height);\r\n        this.camera.updateProjectionMatrix();\r\n\r\n    }\r\n    render(){\r\n        this.offset.x = lerp(this.offset.x, this.targetX, 0.1);\r\n        this.offset.y = lerp(this.offset.y, this.targetY, 0.1);\r\n        this.uniforms.uOffset.value.set((this.targetX-this.offset.x)*0.003, -(this.targetY-this.offset.y)* 0.003);\r\n        this.mesh.position.set(this.offset.x-window.innerWidth/2, -this.offset.y+window.innerHeight/2);\r\n\r\n        this.hovered ? (this.uniforms.uAlpha.value=lerp(this.uniforms.uAlpha.value, 1.0, .1)) :\r\n        (this.uniforms.uAlpha.value=lerp(this.uniforms.uAlpha.value, \r\n            0.0,\r\n            0.1\r\n\r\n        ));\r\n       this.renderer.render(this.scene, this.camera);\r\n       window.requestAnimationFrame(this.render.bind(this));\r\n    }\r\n}\r\n\r\nnew Shaded();\r\n\r\n*/\r\n"]}